import{j as G,k as l,p as h,m as xe,b as g,_ as T,s as ct,n as ft,q as N,r as x,t as P,u as ke,d as S,v as K,w as I,x as M,y as Fe,z as re,A as oe,o as p,B as E,a as dt,l as V,C as $e,D as Ee,E as Te,F as gt,G as ht,H as D,I as pt,J as yt,K as mt,c as bt,L as Ie,M as Pt,N as Ae,O as _t,P as k,Q as St,R as Rt,S as ie,g as se,i as q,h as wt,T as vt}from"../chunks/chunk-6ae69957.js";function v(e){return typeof e!="object"||e===null?!1:Object.getPrototypeOf(e)===null?!0:e.constructor.name==="Object"}function ye(e){return"["+e.map(t=>"'"+t+"'").join(", ")+"]"}function Q(e,t){const n=Object.getOwnPropertyDescriptor(e,t);return!!n&&!("value"in n)&&!!n.get}function Ct(e){return typeof e=="object"&&e!==null&&"then"in e&&G(e.then)}function Ot(e){return[null,void 0].includes(e)?String(e):["boolean","number","string"].includes(typeof e)?JSON.stringify(e):null}function xt(e){return e.replace(/[/\-\\^$*+?.()|[\]{}]/g,"\\$&")}function $(e,t,n){const r=Ft(e,t);if(r===null)return null;const{value:o,definedAt:i}=r;return n&&kt(o,n,t,i),r}function kt(e,t,n,r){l(e!==null);const o=typeof e;if(o===t)return;const i=Ot(e),a=i!==null?`value ${h.cyan(i)}`:`type ${h.cyan(o)}`,f=`${xe("Config",n,{definedAt:r})} has an invalid ${a}: it should be a ${h.cyan(t)} instead`;g(!1,f)}function Ft(e,t){const n=e.configValues[t];return!n||n.value===null?null:n}const $t=["Page"],Et=Object.freeze(Object.defineProperty({__proto__:null,exportNames:$t},Symbol.toStringTag,{value:"Module"})),Tt=["Page"],It=Object.freeze(Object.defineProperty({__proto__:null,exportNames:Tt},Symbol.toStringTag,{value:"Module"})),At=["Page"],Ht=Object.freeze(Object.defineProperty({__proto__:null,exportNames:At},Symbol.toStringTag,{value:"Module"})),Nt=["render","passToClient"],jt=Object.freeze(Object.defineProperty({__proto__:null,exportNames:Nt},Symbol.toStringTag,{value:"Module"})),Bt=["render"],Lt=Object.freeze(Object.defineProperty({__proto__:null,exportNames:Bt},Symbol.toStringTag,{value:"Module"})),ae={},He={},Wt={},Y={},Dt=[],Ne={},Vt=!0,Ut=[],zt={configValuesImported:[]},Gt=Object.assign({"/pages/about/index.page.tsx":()=>T(()=>import("./pages_about_index.page.6650bf63.js"),["assets/entries/pages_about_index.page.6650bf63.js","assets/chunks/chunk-529f355d.js","assets/static/index.page.f1aef519.css"]),"/pages/index/index.page.tsx":()=>T(()=>import("./pages_index_index.page.d5d7acaa.js"),["assets/entries/pages_index_index.page.d5d7acaa.js","assets/chunks/chunk-529f355d.js"]),"/renderer/_error.page.tsx":()=>T(()=>import("./renderer_error.page.78d66a6e.js"),["assets/entries/renderer_error.page.78d66a6e.js","assets/chunks/chunk-529f355d.js"])}),Kt={...Gt};ae[".page"]=Kt;const Mt=Object.assign({"/pages/about/index.page.tsx":Et,"/pages/index/index.page.tsx":It,"/renderer/_error.page.tsx":Ht}),Yt={...Mt};Y[".page"]=Yt;const Jt=Object.assign({"/renderer/_default.page.server.tsx":jt}),qt={...Jt};Y[".page.server"]=qt;const Qt=Object.assign({}),Xt={...Qt};He[".page.route"]=Xt;const Zt=Object.assign({"/renderer/_default.page.client.tsx":()=>T(()=>import("./renderer_default.page.client.59054342.js"),["assets/entries/renderer_default.page.client.59054342.js","assets/chunks/chunk-529f355d.js","assets/entries/renderer_default.page.server.extractAssets.334717de.js","assets/static/default.page.server.d4835ae9.css"])}),en={...Zt};ae[".page.client"]=en;const tn=Object.assign({"/renderer/_default.page.client.tsx":Lt}),nn={...tn};Y[".page.client"]=nn;const rn=Object.assign({"/renderer/_default.page.server.tsx":()=>T(()=>import("./renderer_default.page.server.extractAssets.334717de.js"),["assets/entries/renderer_default.page.server.extractAssets.334717de.js","assets/static/default.page.server.d4835ae9.css"])}),on={...rn};Ne[".page.server"]=on;const sn=Object.freeze(Object.defineProperty({__proto__:null,isGeneratedFile:Vt,neverLoaded:Ne,pageConfigGlobalSerialized:zt,pageConfigsSerialized:Ut,pageFilesEager:He,pageFilesExportNamesEager:Y,pageFilesExportNamesLazy:Wt,pageFilesLazy:ae,pageFilesList:Dt},Symbol.toStringTag,{value:"Module"}));ct(sn);function an(){ft(),N()}function ln(){var r,o,i,a;const e=!!((o=(r=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:r.renderers)!=null&&o.size),t=!!((a=(i=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:i.rendererInterfaces)!=null&&a.size),n=!!window.__vite_plugin_react_preamble_installed__;return e||t||n}function je(e,t){const n=Object.keys,r=typeof e;return e&&t&&r==="object"&&r===typeof t?n(e).length===n(t).length&&n(e).every(i=>je(e[i],t[i])):e===t}function un(e,t){return x(e)&&x(t)&&e.constructor===t.constructor&&je({...e,stack:null},{...t,stack:null})&&t.message===t.message}function U(e){window.location.href=e}function cn(e){return new Promise(t=>setTimeout(t,e))}function fn(e,t){let n=!1;return()=>{n||(n=!0,setTimeout(()=>{n=!1,e()},t))}}function Be(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="hidden"&&e()})}function dn(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&e()})}function gn(e){return!e.startsWith("/")&&!e.startsWith(".")&&!e.startsWith("?")&&e!==""}an();function Le(){let e=window.history.state;e||(e={});let t=!1;"timestamp"in e||(t=!0,e.timestamp=ce()),"scrollPosition"in e||(t=!0,e.scrollPosition=ue()),"triggedBy"in e||(e.triggedBy="browser"),We(e),t&&fe(e)}function le(){const e=window.history.state||{};return We(e),e}function ue(){return{x:window.scrollX,y:window.scrollY}}function ce(){return new Date().getTime()}function me(){const e=ue(),t=le();fe({...t,scrollPosition:e})}function hn(e,t){if(t)fe(le(),e);else{const n=ce();pn({timestamp:n,scrollPosition:null,triggedBy:"vike"},e)}}function We(e){if(l(x(e)),"timestamp"in e){const{timestamp:t}=e;l(typeof t=="number")}if("scrollPosition"in e){const{scrollPosition:t}=e;t!==null&&l(P(t,"x","number")&&P(t,"y","number"))}}function fe(e,t){window.history.replaceState(e,"",t??null)}function pn(e,t){window.history.pushState(e,"",t)}function yn(){const e=history.pushState;history.pushState=(t={},...n)=>{g(t==null||x(t),"history.pushState(state) argument state must be an object");const r={scrollPosition:ue(),timestamp:ce(),...t,triggedBy:"user"};return e.apply(history,[r,...n])}}async function mn(e,t){const r=ke(e,t).filter(i=>i.fileType===".page.server");return await Promise.all(r.map(async i=>{i.exportNames||(l(i.loadExportNames,t),await i.loadExportNames())})),{hasOnBeforeRenderServerSideOnlyHook:r.some(({exportNames:i})=>(l(i),i.includes("onBeforeRender")))}}const be=["urlPathname","urlParsed"],bn=["Page","pageExports","exports"];function De(e){[...bn,...be].forEach(n=>{n in e&&(be.includes(n)?(l(n.startsWith("url")),S(!1,`pageContext.${n} is already available in the browser when using Client Routing; adding '${n}' to passToClient has no effect`,{onlyOnce:!0})):S(!1,`pageContext.${n} is a built-in that cannot be overriden; adding '${n}' to passToClient has no effect`,{onlyOnce:!0}),delete e[n])})}const Pn="/";function _n(e,t,n){const{pathnameOriginal:r,searchOriginal:o,hashOriginal:i}=K(e,Pn);e.startsWith("/")&&l(e===`${r}${o||""}${i||""}`,{url:e});const a=r.endsWith("/");let s;return n&&r!=="/"?(a?s=I(r,0,-1):s=r,l(!s.endsWith("/"),{url:e}),l(s!=="")):s=r+(a?"":"/")+"index",l(s),s=s+t,`${s}${o||""}${i||""}`}const Sn=".pageContext.json",Rn=!1;function wn(e){return _n(e,Sn,Rn)}function Ve(e,{hookName:t,hookFilePath:n}){if(e==null)return;l(!t.endsWith(")"));const r=`The ${h.cyan("pageContext")} object provided by the ${t}() hook defined by ${n}`;g(x(e),`${r} should be an object (but it's ${h.cyan(`typeof pageContext === ${JSON.stringify(typeof e)}`)} instead)`),g(!("_objectCreatedByVike"in e),`${r} shouldn't be the whole ${h.cyan("pageContext")} object, see https://vike.dev/pageContext-manipulation#do-not-return-entire-pagecontext`),S(!("_pageId"in e),`${r} sets ${h.cyan("pageContext._pageId")} which means that Vike's routing is overriden. This is an experimental feature: make sure to contact a vike maintainer before using this.`,{onlyOnce:!0}),g(!("is404"in e),`${r} sets ${h.cyan("pageContext.is404")} which is forbidden, use ${h.cyan("throw render()")} instead, see https://vike.dev/render`)}function vn(e,t,n){l(!n.endsWith(" "));const r=[],o=Object.keys(e);for(const i of o)t.includes(i)||r.push(i);g(r.length===0,[n,"returned an object with following unknown keys:",ye(r)+".","Only following keys are allowed:",ye(t)+"."].join(" "))}function Cn(e,t){if(e==null)return;const n=`The onBeforeRender() hook defined by ${t}`;g(v(e),`${n} should return a plain JavaScript object, ${h.cyan("undefined")}, or ${h.cyan("null")}`),vn(e,["pageContext"],n),e.pageContext&&Ve(e.pageContext,{hookName:"onBeforeRender",hookFilePath:t})}function On(e,t){if(!v(e))return!1;for(const n of Object.keys(e))if(!t.includes(n))return!1;return!0}function xn(e){return typeof e=="object"&&e!==null&&Object.values(e).every(t=>typeof t=="string")}function kn(e,t){if(l(e.length>0),e.length===1)return e[0];const n=e.slice(0,e.length-1),r=e[e.length-1];return n.join(", ")+` ${t} `+r}M()&&N();async function Fn(e,t){let n;if(e._pageFilesAll.length>0?(l(e._pageConfigs.length===0),n=$n(e._pageId,e._pageFilesAll)):n=Fe(e,"guard"),!n)return;const r=n.hookFn;let o=e;const i=t(e);i&&(o=i);const a=await re(()=>r(o),"guard",n.hookFilePath);g(a===void 0,`The guard() hook of ${n.hookFilePath} returns a value, but guard() doesn't accept any return value`)}function $n(e,t){const n=t.find(s=>s.pageId===e&&s.fileType===".page.route");if(!n)return null;const{filePath:r,fileExports:o}=n;l(o);const i=o.guard;if(!i)return null;const a=r;return g(G(i),`guard() defined by ${a} should be a function`),{hookFn:i,hookName:"guard",hookFilePath:a}}function En(e){const t=new Error("AbortRender");return p(t,{_pageContextAbort:e,[Ue]:!0}),t}const Ue="_isAbortError";function Pe(e){return typeof e=="object"&&e!==null&&Ue in e}function Tn(e){return e._urlRewrite||e._urlRedirect||e.abortStatusCode?(l(P(e,"_abortCall","string")),!0):!1}function In(e,t,n){if(t)return;const r=n._urlRewrite??n.urlOriginal;l(r);const o=e._pageContextAbort._abortCall;oe(!1,`${h.cyan(o)} intercepted while rendering ${h.cyan(r)}`,{onlyOnce:!1})}function An(e){Hn(e);const t={_urlRewrite:null};return e.forEach(n=>{Object.assign(t,n)}),t}function Hn(e){const t=[];e.forEach(n=>{const r=n._urlRewrite;{const o=t.indexOf(r);if(o!==-1){const i=[...t.slice(o),r].map(a=>`render('${a}')`).join(" => ");g(!1,`Infinite loop of render() calls: ${i}`)}}t.push(r)})}function Nn(e,t){const n=[e>0&&h.cyan("throw render('/some-url')"),t>0&&h.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");g(e+t<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}const ze=E("router/getPageContext.ts",{});async function jn(e){const t=dt();De(t),p(t,{isHydration:!0,_hasPageContextFromClient:!1}),p(t,await V(t._pageId,e));{const n={...e,...t};if(await Vn(n)){const r=await Ke(n);p(t,r)}}return Me(t),t}async function Bn(e){const t=$e(e._pageFilesAll,e._pageConfigs);if(!t)throw new Error("No error page defined.");const n={isHydration:!1,_pageId:t};return p(n,await Ge({...e,...n},!0)),n}async function Ln(e){const t={isHydration:!1,_pageId:e._pageId};return p(t,await Ge({...e,...t},!1)),Me(t),t}async function Ge(e,t){let n={};if(p(n,await V(e._pageId,e)),!t&&await Wn({...e,...n})){const r=await Un(e);if(!r._isError)p(n,r);else{const o=$e(e._pageFilesAll,e._pageConfigs);l(o),n={},p(n,{isHydration:!1,_pageId:o}),p(n,await V(n._pageId,e)),l(P(r,"is404","boolean")),l(P(r,"pageProps","object")),l(P(r.pageProps,"is404","boolean")),l(!("serverSideError"in r)),p(n,r)}}else p(n,{_hasPageContextFromServer:!1}),t||await Fn({_hasPageContextFromClient:!1,...e,...n},r=>Ee(r,!0));{const r=await Ke({...e,...n});p(n,r)}return n}async function Ke(e){const t=Fe(e,"onBeforeRender");if(!t)return{_hasPageContextFromClient:!1};const n=t.hookFn,r={_hasPageContextFromClient:!0},o=Ee({...e,...r},!0),i=await re(()=>n(o),"onBeforeRender",t.hookFilePath);Cn(i,t.hookFilePath);const a=i==null?void 0:i.pageContext;return p(r,a),r}function Me(e){e._pageContextInitHasClientData&&(ze.pageContextInitHasClientData=!0)}async function Wn(e){return!!ze.pageContextInitHasClientData||await Dn(e)}async function Dn(e){var t;if(e._pageConfigs.length>0){const n=Te(e._pageId,e._pageConfigs);return((t=$(n,"onBeforeRenderEnv"))==null?void 0:t.value)==="server-only"}else{const{hasOnBeforeRenderServerSideOnlyHook:n}=await mn(e._pageFilesAll,e._pageId);return n}}async function Vn(e){var t;if(e._pageConfigs.length>0){const n=Te(e._pageId,e._pageConfigs);return((t=$(n,"onBeforeRenderEnv"))==null?void 0:t.value)==="client-only"}else return!1}async function Un(e){const t=wn(e._urlRewrite??e.urlOriginal),n=await fetch(t);{const i=n.headers.get("content-type"),a="application/json",s=i&&i.includes(a);if(!s&&n.status===404)throw U(e.urlOriginal),Gn();g(s,`Wrong Content-Type for ${t}: it should be ${a} but it's ${i} instead. Make sure to properly use pageContext.httpResponse.headers, see https://vike.dev/renderPage`)}const r=await n.text(),o=gt(r);if(l(x(o)),"serverSideError"in o)throw ht("The pageContext object couldn't be fetched from the server as an error occurred on the server-side. Check your server logs.");if(Tn(o))throw En(o);return l(P(o,"_pageId","string")),De(o),p(o,{_hasPageContextFromServer:!0}),o}function zn(e){return x(e)&&!!e._alreadyServerSideRouted}function Gn(){const e=new Error("Page doesn't exist");return Object.assign(e,{_alreadyServerSideRouted:!0}),e}function Ye(e,t=!0){l(e.urlOriginal),"urlPathname"in e&&(l(typeof e.urlPathname=="string"),l(Q(e,"urlPathname"))),"urlParsed"in e&&l(Q(e,"urlParsed")),"url"in e&&l(Q(e,"url")),Object.defineProperty(e,"urlPathname",{get:qe,enumerable:t,configurable:!0}),Object.defineProperty(e,"url",{get:Kn,enumerable:!1,configurable:!0}),Object.defineProperty(e,"urlParsed",{get:Mn,enumerable:t,configurable:!0})}function Je(e){let t=e._urlHandler;t||(t=o=>o);let n=e._urlRewrite??e.urlLogical??e.urlOriginal;n=t(n);const r=e._baseServer;return l(n&&typeof n=="string"),l(r.startsWith("/")),K(n,r)}function qe(){const{pathname:e}=Je(this),t=e;return l(t.startsWith("/")),t}function Kn(){return S(!1,"`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vike.dev/migration/0.4.23 for more information.)",{onlyOnce:!0,showStackTrace:!0}),qe.call(this)}function Mn(){const e=Je(this),{origin:t,pathname:n,pathnameOriginal:r,search:o,searchAll:i,searchOriginal:a,hash:s,hashOriginal:f}=e,d=M(),b=u=>{S(d,`pageContext.urlParsed.${u} isn't available on the server-side (HTTP requests don't include the URL hash by design)`,{onlyOnce:!0,showStackTrace:!0})},c={origin:t,pathname:n,pathnameOriginal:r,search:o,searchAll:i,searchOriginal:a,get hash(){return b("hash"),s},get hashOriginal(){return b("hashOriginal"),f},get hashString(){return S(!1,"pageContext.urlParsed.hashString has been renamed to pageContext.urlParsed.hashOriginal",{onlyOnce:!0,showStackTrace:!0}),b("hashString"),f},get searchString(){return S(!1,"pageContext.urlParsed.searchString has been renamed to pageContext.urlParsed.searchOriginal",{onlyOnce:!0,showStackTrace:!0}),a}};return B(c,"hashString"),B(c,"searchString"),d||(B(c,"hash"),B(c,"hashOriginal")),c}function B(e,t){const n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(e,t,{...n,enumerable:!1})}function Yn(e){l(typeof e.urlOriginal=="string"),l(typeof e.urlPathname=="string"),l(v(e.urlParsed)),l(e.urlPathname===e.urlParsed.pathname)}function Jn(e,t){const r=t.filter(({filesystemRoot:i})=>e.startsWith(i)).sort(D(({filesystemRoot:i})=>i.length))[0];let o;if(r){const{filesystemRoot:i,urlRoot:a}=r,s={pageId:e,filesystemRoot:i,urlRoot:a};l(a.startsWith("/")&&e.startsWith("/")&&i.startsWith("/"),s),l(e.startsWith(i),s),i!=="/"?(l(!i.endsWith("/"),s),o=I(e,i.length,0)):o=e,l(o.startsWith("/"),s),o=a+(a.endsWith("/")?"":"/")+I(o,1,0)}else o=e;return l(o.startsWith("/")),o=o.split("/").filter(i=>i!=="pages"&&i!=="src"&&i!=="index").join("/"),l(!o.includes(".page.")),l(!o.endsWith(".")),o.endsWith("/index")&&(o=I(o,0,-6)),o===""&&(o="/"),l(o.startsWith("/")),l(!o.endsWith("/")||o==="/"),o}async function qn(e,t,n){Yn(t);let r=e(t);if(Qe(r,`The Route Function ${n}`),r=await r,r===!1)return null;if(r===!0&&(r={}),g(v(r),`The Route Function ${n} should return a boolean or a plain JavaScript object (but it's ${h.cyan(`typeof result === ${JSON.stringify(typeof r)}`)} instead)`),"match"in r){const{match:a}=r;if(g(typeof a=="boolean",`The ${h.cyan("match")} value returned by the Route Function ${n} should be a boolean.`),!a)return null}let o=null;"precedence"in r&&(o=r.precedence,g(typeof o=="number",`The ${h.cyan("precedence")} value returned by the Route Function ${n} should be a number.`)),Xe(r,`The ${h.cyan("routeParams")} object returned by the Route Function ${n} should`);const i=r.routeParams||{};return g(!("pageContext"in r),`Providing ${h.cyan("pageContext")} in Route Functions is prohibited, see https://vike.dev/route-function#cannot-provide-pagecontext`),l(v(i)),Object.keys(r).forEach(a=>{g(a==="match"||a==="routeParams"||a==="precedence",`The Route Function ${n} returned an object with an unknown property ${h.cyan(a)} (the known properties are ${h.cyan("match")}, ${h.cyan("routeParams")}, and ${h.cyan("precedence")})`)}),{precedence:o,routeParams:i}}function Qe(e,t){S(!Ct(e),`${t} returned a promise, but asynchronous routing is deprecated and will be removed in the next major release, see https://vike.dev/route-function#async`,{onlyOnce:!0})}function _e(){const e=h.cyan("iKnowThePerformanceRisksOfAsyncRouteFunctions");S(!1,`${e} is deprecated and will be removed in the next major release`,{onlyOnce:!0})}function Xe(e,t){l(t.endsWith(" should")),P(e,"routeParams")&&(l(t.endsWith(" should")),g(v(e.routeParams),`${t} be a plain JavaScript object.`),g(xn(e.routeParams),`${t} only hold string values.`))}async function Qn(e,t,n,r){await Promise.all(e.filter(s=>s.fileType===".page.route").map(s=>{var f;return(f=s.loadFile)==null?void 0:f.call(s)}));const{onBeforeRouteHook:o,filesystemRoots:i}=Zn(e,t,n);return{pageRoutes:Xn(i,e,t,r),onBeforeRouteHook:o}}function Xn(e,t,n,r){const o=[];let i=[...r];if(n.length>0){l(e===null);const a=!0;n.filter(s=>!s.isErrorPage).forEach(s=>{const f=s.pageId;i=tr(i,f);let d=null;{const b="route",c=$(s,b);if(c){const u=c.value,m=pt(c.definedAt,b);typeof u=="string"?d={pageId:f,comesFromV1PageConfig:a,routeString:u,routeDefinedAt:m,routeType:"STRING"}:(l(G(u)),$(s,"iKnowThePerformanceRisksOfAsyncRouteFunctions","boolean")&&_e(),d={pageId:f,comesFromV1PageConfig:a,routeFunction:u,routeDefinedAt:m,routeType:"FUNCTION"})}}if(!d){const{routeFilesystem:b}=s;l(b);const{routeString:c,definedBy:u}=b;l(b.routeString.startsWith("/")),d={pageId:f,routeFilesystemDefinedBy:u,comesFromV1PageConfig:a,routeString:c,routeDefinedAt:null,routeType:"FILESYSTEM"}}l(d),o.push(d)})}if(n.length===0){l(e);const a=!1;i.filter(s=>!yt(s)).forEach(s=>{const f=t.find(d=>d.pageId===s&&d.fileType===".page.route");if(!f||!("default"in f.fileExports)){const d=Jn(s,e);l(d.startsWith("/")),l(!d.endsWith("/")||d==="/"),o.push({pageId:s,comesFromV1PageConfig:a,routeString:d,routeDefinedAt:null,routeFilesystemDefinedBy:`${s}.page.*`,routeType:"FILESYSTEM"})}else{const{filePath:d,fileExports:b}=f;if(l(b.default),P(b,"default","string")){const c=b.default;g(c.startsWith("/"),`A Route String should start with a leading slash '/' but ${d} has \`export default '${c}'\`. Make sure to \`export default '/${c}'\` instead.`),o.push({pageId:s,comesFromV1PageConfig:a,routeString:c,routeDefinedAt:d,routeType:"STRING"});return}if(P(b,"default","function")){const c=b.default;"iKnowThePerformanceRisksOfAsyncRouteFunctions"in b&&_e(),o.push({pageId:s,comesFromV1PageConfig:a,routeFunction:c,routeDefinedAt:d,routeType:"FUNCTION"});return}g(!1,`The default export of ${d} should be a string or a function.`)}})}return o}function Zn(e,t,n){var i;if(t.length>0){const a="onBeforeRoute";if((i=n.configValues[a])!=null&&i.value){const s=n.configValues[a],{value:f}=s,d=mt(s),b=xe("Hook",a,s);return g(G(f),`${b} should be a function.`),{onBeforeRouteHook:{hookFilePath:d,onBeforeRoute:f},filesystemRoots:null}}return{onBeforeRouteHook:null,filesystemRoots:null}}let r=null;const o=[];return e.filter(a=>a.fileType===".page.route"&&a.isDefaultPageFile).forEach(({filePath:a,fileExports:s})=>{if(l(s),"onBeforeRoute"in s){g(P(s,"onBeforeRoute","function"),`\`export { onBeforeRoute }\` of ${a} should be a function.`);const{onBeforeRoute:f}=s;r={hookFilePath:`${a} > \`export { onBeforeRoute }\``,onBeforeRoute:f}}"filesystemRoutingRoot"in s&&(g(P(s,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${a} should be a string.`),g(P(s,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${a} is \`'${s.filesystemRoutingRoot}'\` but it should start with a leading slash \`/\`.`),o.push({filesystemRoot:er(a),urlRoot:s.filesystemRoutingRoot}))}),{onBeforeRouteHook:r,filesystemRoots:o}}function er(e){l(e.startsWith("/")),l(!e.endsWith("/"));const t=e.split("/"),n=I(t,0,-1).join("/")||"/";return l(n.startsWith("/")),l(!n.endsWith("/")||n==="/"),n}function tr(e,t){const{length:n}=e;return e=e.filter(r=>r!==t),l(e.length===n-1),e}function Ze(){const e="/";return l(nr(e)),e}function nr(e){return e.startsWith("/")}const X=E("createPageContext.ts",{});async function et(e){X.pageFilesData||(X.pageFilesData=await bt(!0));const{pageFilesAll:t,allPageIds:n,pageConfigs:r,pageConfigGlobal:o}=X.pageFilesData,{pageRoutes:i,onBeforeRouteHook:a}=await Qn(t,r,o,n),s=Ze();l(Ie(s));const d={urlOriginal:e,_objectCreatedByVike:!0,_urlHandler:null,_urlRewrite:null,_baseServer:s,_isProduction:!0,_pageFilesAll:t,_pageConfigs:r,_pageConfigGlobal:o,_allPageIds:n,_pageRoutes:i,_onBeforeRouteHook:a};return Ye(d),d}function tt(e){const t=e.getAttribute("href");return!!(t===null||t===""||gn(t)||or(e)||ir(t)||!sr(t)||!Pt(t)||!rr(e))}function rr(e){if(ar()){const n=e.getAttribute("data-vike-link");return n!==null&&n!=="false"}else return!0}function or(e){const t=e.getAttribute("target"),n=e.getAttribute("rel");return t==="_blank"||t==="_external"||n==="external"||e.hasAttribute("download")}function ir(e){if(e.startsWith("#"))return!0;const t=n=>n.split("#")[0];return!!(e.includes("#")&&t(e)===t(window.location.href))}function sr(e){const t=Ze();l(Ie(t));const{hasBaseServer:n}=K(e,t);return n}function ar(){return!!window._disableAutomaticLinkInterception}function lr(e,t){let n=ur(e,t);return n==="viewport"&&!e._isProduction&&(oe(!1,"Viewport prefetching is disabled in development",{onlyOnce:!0}),n="hover"),{prefetchStaticAssets:n}}function ur(e,t){{const n=cr(t);if(n!==null)return n}if("prefetchLinks"in e.exports&&g(!1,"`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead."),"prefetchStaticAssets"in e.exports){const{prefetchStaticAssets:n}=e.exports;if(n===!1)return!1;if(n==="hover")return"hover";if(n==="viewport")return"viewport";const r="prefetchStaticAssets value should be false, 'hover', or 'viewport'";g(v(n),r);const o=Object.keys(n);g(o.length===1&&o[0]==="when",r);const{when:i}=n;if(i==="HOVER"||i==="VIEWPORT"){const a=i.toLowerCase();return S(!1,`prefetchStaticAssets value \`{ when: '${i}' }\` is outdated: set prefetchStaticAssets to '${a}' instead`,{onlyOnce:!0}),a}g(!1,r)}return"hover"}function cr(e){const t=e.getAttribute("data-prefetch-static-assets"),n=e.getAttribute("data-prefetch");if(t===null&&n===null)return null;const r="The attribute data-prefetch is outdated, use data-prefetch-static-assets instead.";if(t){if(g(n===null,r),t==="hover"||t==="viewport")return t;if(t==="false")return!1;g(!1,`data-prefetch-static-assets has value "${t}" but it should instead be "false", "hover", or "viewport"`)}if(n){if(l(!t),S(!1,r,{onlyOnce:!0}),n==="true")return"viewport";if(n==="false")return"hover";g(!1,`data-prefetch has value "${n}" but it should instead be "true" or "false"`)}l(!1)}const nt=new Map;function fr(e){const t=rt(e);return nt.has(t)}function dr(e){const t=rt(e);nt.set(t,!0)}function rt(e){return K(e,"/").pathname}function A(e){return e.fileType===".css"?[]:e.exportNames?e.exportNames:(l(e.fileExports,e.filePath),Object.keys(e.fileExports))}function gr({pageFilesClientSide:e,pageFilesServerSide:t,pageId:n}){return{isHtmlOnly:r(),isClientRouting:i()};function r(){return t.some(s=>s.pageId===n&&s.fileType===".page")?(o(),!1):!(!t.some(s=>s.pageId===n&&s.fileType===".page.server")||e.some(s=>s.pageId===n&&s.fileType===".page.client"&&A(s).includes("render")))}function o(){const a=e.some(s=>A(s).includes("render"));g(a,["No client-side `render()` hook found.","See https://vike.dev/render-modes for more information.",["Loaded client-side page files (none of them `export { render }`):",...e.map((s,f)=>` (${f+1}): ${s.filePath}`)].join(`
`)].join(" "))}function i(){return e.some(s=>A(s).includes("clientRouting"))}}function hr({pageFilesClientSide:e,pageFilesServerSide:t,isHtmlOnly:n,isClientRouting:r}){let o=[];const i=t.filter(s=>!e.includes(s)),a=[];if(a.push(...e.map(s=>({id:s.filePath,onlyAssets:!1,eagerlyImported:!1}))),a.push(...i.map(s=>({id:s.filePath,onlyAssets:!0,eagerlyImported:!1}))),n)o=e.map(s=>s.filePath);else{const s=pr(r);a.push({id:s,onlyAssets:!1,eagerlyImported:!1}),o=[s]}return{clientEntries:o,clientDependencies:a}}function pr(e){return e?"@@vike/dist/esm/client/client-routing-runtime/entry.js":"@@vike/dist/esm/client/server-routing-runtime/entry.js"}function yr(e,t){let n=Ae(e,t);const r=ke(e,t),{isHtmlOnly:o,isClientRouting:i}=gr({pageFilesClientSide:n,pageFilesServerSide:r,pageId:t});o&&(n=n.filter(f=>f.isEnv("CLIENT_ONLY")&&!A(f).includes("render")),n=br(n));const{clientEntries:a,clientDependencies:s}=hr({pageFilesClientSide:n,pageFilesServerSide:r,isHtmlOnly:o,isClientRouting:i});return{isHtmlOnly:o,isClientRouting:i,clientEntries:a,clientDependencies:s,pageFilesClientSide:n,pageFilesServerSide:r}}async function mr(e,t,{sharedPageFilesAlreadyLoaded:n}){const r=Ae(e,t);await Promise.all(r.map(async o=>{var i;l(o.isEnv("CLIENT_ONLY")||o.isEnv("CLIENT_AND_SERVER")),!(n&&o.isEnv("CLIENT_AND_SERVER"))&&await((i=o.loadExportNames)==null?void 0:i.call(o))}))}function br(e){const t=[];for(const n of e)if(t.push(n),A(n).includes("overrideDefaultPages"))break;return t}function Pr(e,t,n){var r,o;if(e){const i=((r=$(e,"clientRouting","boolean"))==null?void 0:r.value)??!1;return{isClientSideRenderable:((o=$(e,"isClientSideRenderable","boolean"))==null?void 0:o.value)??!1,isClientRouting:i}}else{const{isHtmlOnly:i,isClientRouting:a}=yr(t,n);return{isClientSideRenderable:!i,isClientRouting:a}}}async function ot(e,t){await mr(t._pageFilesAll,e,{sharedPageFilesAlreadyLoaded:!1});const n=_t(t._pageConfigs,e),{isClientSideRenderable:r,isClientRouting:o}=Pr(n,t._pageFilesAll,e);return r&&o}const it="@",ee=":";function _r(e,t="Invalid"){let n=`${t} Route String ${O(e)}`;g(e!=="",`${n} (empty string): set it to ${O("/")} instead`),g(["/","*"].includes(e[0]),`${n}: it should start with ${O("/")} or ${O("*")}`),g(!e.includes("**"),`${n}: set it to ${O(e.split("**").join("*"))} instead`)}function te(e,t){_r(e);const n=st(e),r=n.map(c=>c.param?"[^/]+":c.glob?c.isLastDir?"|/.*":".*":xt(c.static)).map(c=>`(${c})`).join(""),o=new RegExp(`^${r}/?$`),i=t.match(o);if(!i)return null;const a={},[s,...f]=i;let d=0;const b=n.filter(c=>c.glob).length>1;return n.forEach((c,u)=>{let m=f[u];if(c.param&&(a[c.param]=m),c.glob){const C=`*${b?++d:""}`;c.isLastDir&&(m=m.slice(1)),a[C]=m}}),{routeParams:a}}function st(e){const t=[],n=o=>{const i=t[t.length-1];i!=null&&i.static?i.static+=o:t.push({static:o})},r=e.split("/");return r.forEach((o,i)=>{const a=i===0,s=i===r.length-1;Sr(o)?(S(!o.startsWith(ee),`Outdated Route String ${O(e)}, use ${O(e.split(ee).join(it))} instead`,{onlyOnce:!0}),a||n("/"),t.push({param:o.slice(1)})):o==="*"&&s&&e!=="*"&&e!=="/*"?t.push({glob:!0,isLastDir:!0}):(a||n("/"),o.split("*").forEach((f,d)=>{d!==0&&t.push({glob:!0}),f!==""&&n(f)}))}),t}function L(e){const t=st(e),n=s=>(s==null?void 0:s.split("/").filter(Boolean).length)||0;let r=0;for(const s of t){if(!s.static)break;r+=n(s.static)}const o=t.map(s=>n(s.static)).reduce((s,f)=>s+f,0),i=t.filter(s=>s.param).length,a=t.filter(s=>s.glob).length;return{numberOfStaticPartsBeginning:r,numberOfStaticParts:o,numberOfParams:i,numberOfGlobs:a}}function Sr(e){return e.startsWith(it)||e.startsWith(ee)}function Se(e){const n=te(e,e);return l(n),Object.keys(n.routeParams).length===0}function O(e){return M()?`'${e}'`:(e===""&&(e="''"),h.cyan(e))}function Rr(e){e.sort(wr).sort(k(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence<0)).sort(k(t=>t.routeType==="STRING"&&Se(t.routeString)===!1)).sort(k(t=>t.routeType==="FUNCTION"&&!t.precedence)).sort(k(t=>t.routeType==="STRING"&&Se(t.routeString)===!0)).sort(k(t=>t.routeType==="FILESYSTEM")).sort(k(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence>0))}function wr(e,t){{const n=e.precedence??0,r=t.precedence??0;if(n!==r)return n>r?-1:1}if(!t.routeString||!e.routeString)return 0;{const r=D(o=>L(o).numberOfStaticPartsBeginning)(e.routeString,t.routeString);if(r!==0)return r}{const r=D(o=>L(o).numberOfStaticParts)(e.routeString,t.routeString);if(r!==0)return r}{const r=St(o=>L(o).numberOfGlobs)(e.routeString,t.routeString);if(r!==0)return r}{const r=D(o=>L(o).numberOfParams)(e.routeString,t.routeString);if(r!==0)return r}return 0}async function vr(e){const t={};if(!e._onBeforeRouteHook)return null;const n=await Cr(e._onBeforeRouteHook,e);return n&&(p(t,n),P(t,"_pageId","string")||P(t,"_pageId","null"))?(P(t,"routeParams")?l(P(t,"routeParams","object")):p(t,{routeParams:{}}),p(t,{_routingProvidedByOnBeforeRouteHook:!0,_debugRouteMatches:"CUSTOM_ROUTING"}),t):(p(t,{_routingProvidedByOnBeforeRouteHook:!1}),t)}async function Cr(e,t){let n=e.onBeforeRoute(t);Qe(n,`The onBeforeRoute() hook ${e.hookFilePath}`),n=await n;const r=`The onBeforeRoute() hook defined by ${e.hookFilePath}`;if(g(n==null||On(n,["pageContext"])&&P(n,"pageContext"),`${r} should return ${h.cyan("null")}, ${h.cyan("undefined")}, or a plain JavaScript object ${h.cyan("{ pageContext: { /* ... */ } }")}`),n==null)return null;if(g(P(n,"pageContext","object"),`${r} returned ${h.cyan("{ pageContext }")} but pageContext should be a plain JavaScript object.`),P(n.pageContext,"_pageId")&&!P(n.pageContext,"_pageId","null")){const a=`${r} returned ${h.cyan("{ pageContext: { _pageId } }")} but ${h.cyan("_pageId")} should be`;g(P(n.pageContext,"_pageId","string"),`${a} a string or null`),g(t._allPageIds.includes(n.pageContext._pageId),`${a} ${kn(t._allPageIds.map(s=>h.cyan(s)),"or")}`)}P(n.pageContext,"routeParams")&&Xe(n.pageContext,`${r} returned ${h.cyan("{ pageContext: { routeParams } }")} but routeParams should`);const o=a=>`${r} returned ${h.cyan(`{ pageContext: { ${a} } }`)} which is deprecated. Return ${h.cyan("{ pageContext: { urlLogical } }")} instead.`;P(n.pageContext,"url")&&(S(!1,o("url"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.url,delete n.pageContext.url),P(n.pageContext,"urlOriginal")&&(S(!1,o("urlOriginal"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.urlOriginal,delete n.pageContext.urlOriginal),P(n.pageContext,"urlLogical")&&Rt(n.pageContext.urlLogical,`${r} returned ${h.cyan("{ pageContext: { urlLogical } }")} but ${h.cyan("urlLogical")}`),Ve(n.pageContext,{hookFilePath:e.hookFilePath,hookName:"onBeforeRoute"});const i={};return p(i,n.pageContext),i}var W;function Re(...e){var t;W||(W=(t=globalThis.__brillout_debug_createDebugger)==null?void 0:t.call(globalThis,"vike:routing")),W&&W(...e)}M()&&N();async function at(e){Re("Pages routes:",e._pageRoutes),Ye(e);const t={},n=await vr(e);if(n){if(n._routingProvidedByOnBeforeRouteHook)return l(n._pageId),n;p(t,n)}const r={};p(r,e),p(r,n);const o=r._allPageIds;l(o.length>=0),g(r._pageFilesAll.length>0||r._pageConfigs.length>0,"No *.page.js file found. You must create at least one *.page.js file."),g(o.length>0,"You must create at least one *.page.js file that isn't _default.page.*");const{urlPathname:i}=r;l(i.startsWith("/"));const a=[];await Promise.all(r._pageRoutes.map(async f=>{const{pageId:d,routeType:b}=f;if(f.routeType==="FILESYSTEM"){const{routeString:c}=f,u=te(c,i);if(u){const{routeParams:m}=u;a.push({pageId:d,routeParams:m,routeString:c,routeType:b})}return}if(f.routeType==="STRING"){const{routeString:c}=f,u=te(c,i);if(u){const{routeParams:m}=u;l(b==="STRING"),a.push({pageId:d,routeString:c,routeParams:m,routeType:b})}return}if(f.routeType==="FUNCTION"){const{routeFunction:c,routeDefinedAt:u}=f,m=await qn(c,r,u);if(m){const{routeParams:C,precedence:j}=m;a.push({pageId:d,precedence:j,routeParams:C,routeType:b})}return}l(!1)})),Rr(a);const s=a[0];if(Re(`Route matches for URL ${h.cyan(i)} (in precedence order):`,a),p(t,{_debugRouteMatches:a}),!s)return p(t,{_pageId:null,routeParams:{}}),t;{const{routeParams:f}=s;l(v(f)),p(t,{_pageId:s.pageId,routeParams:s.routeParams})}return t}N();const we=E("prefetch.ts",{linkPrefetchHandlerAdded:new Map});async function Or(e,t){try{await V(e,t)}catch(n){if(ie(n))ne(n,!0);else throw n}}function xr(e){dr(e.urlPathname),[...document.getElementsByTagName("A")].forEach(n=>{if(we.linkPrefetchHandlerAdded.has(n))return;we.linkPrefetchHandlerAdded.set(n,!0);const r=n.getAttribute("href");if(tt(n)||(l(r),fr(r)))return;const{prefetchStaticAssets:o}=lr(e,n);if(o&&(o==="hover"&&(n.addEventListener("mouseover",()=>{Z(r)}),n.addEventListener("touchstart",()=>{Z(r)},{passive:!0})),o==="viewport")){const i=new IntersectionObserver(a=>{a.forEach(s=>{s.isIntersecting&&(Z(r),i.disconnect())})});i.observe(n)}})}async function Z(e){const t=await et(e);let n;try{n=await at(t)}catch{return}n!=null&&n._pageId&&await ot(n._pageId,t)&&await Or(n._pageId,t)}function lt(e){if(e==="preserve-scroll")return;let t;if(e==="scroll-to-top-or-hash"){const n=Fr();if(n&&n!=="top"){const r=document.getElementById(n)||document.getElementsByName(n)[0];if(r){r.scrollIntoView();return}}t={x:0,y:0}}else l("x"in e&&"y"in e),t=e;kr(t)}function kr(e){const t=()=>window.scrollTo(e.x,e.y),n=()=>window.scrollX===e.x&&window.scrollY===e.y;n()||(t(),!n()&&requestAnimationFrame(()=>{t(),!n()&&setTimeout(async()=>{if(t(),n())return;const r=new Date().getTime();for(;;)if(await cn(10),t(),n()||new Date().getTime()-r>100)return},0)}))}function Fr(){let{hash:e}=window.location;return e===""?null:(l(e.startsWith("#")),e=e.slice(1),e)}function $r(){window.addEventListener("scroll",fn(me,Math.ceil(1e3/3)),{passive:!0}),Be(me)}const F=E("onBrowserHistoryNavigation.ts",{previousState:z()});function Er(){window.addEventListener("popstate",()=>{const e=z(),t=e.historyState.scrollPosition||"scroll-to-top-or-hash",n=e.historyState.triggedBy==="user",r=e.urlWithoutHash===F.previousState.urlWithoutHash,o=!e.historyState.timestamp||!F.previousState.historyState.timestamp?null:e.historyState.timestamp<F.previousState.historyState.timestamp;F.previousState=e,r&&!n?window.history.state===null?(Le(),F.previousState=z()):lt(t):H({scrollTarget:t,isBackwardNavigation:o,isUserLandPushStateNavigation:n})})}function z(){return{urlWithoutHash:se({withoutHash:!0}),historyState:le()}}function Tr(){F.previousState=z()}const ut=E("scrollRestoration.ts",{});function Ir(){ve(),Be(ve),dn(()=>ut.initialRenderIsDone&&de())}function Ar(){ut.initialRenderIsDone=!0}function de(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual")}function ve(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="auto")}const _=E("renderPageClientSide.ts",{renderCounter:0});async function H(e){var he,pe;const{scrollTarget:t,urlOriginal:n=se(),overwriteLastHistoryEntry:r=!1,isBackwardNavigation:o,pageContextsFromRewrite:i=[],redirectCount:a=0,isUserLandPushStateNavigation:s,isClientSideNavigation:f=!0}=e,{abortRender:d,setHydrationCanBeAborted:b,isFirstRender:c}=jr();if(l(f===!c),Nn(i.length,a),_.clientRoutingIsDisabled){U(n);return}const u=await et(n);if(d())return;p(u,{isBackwardNavigation:o,isClientSideNavigation:f});{const y=An(i);p(u,y)}let m={};const C=y=>{l(y),l(!("err"in m)),l(!("errorWhileRendering"in u)),m.err=y,u.errorWhileRendering=y};if(!c){try{m={pageContextFromRoute:await at(u)}}catch(y){C(y)}if(d())return;if(m.pageContextFromRoute){const{pageContextFromRoute:y}=m;p(u,y);let R;if(!y._pageId)R=!1;else if(R=await ot(y._pageId,u),d())return;if(!R){U(n);return}const w=y._pageId&&((he=_.previousPageContext)==null?void 0:he._pageId)&&y._pageId===_.previousPageContext._pageId;if(s&&w)return}}const j=!c;if(j&&!_.isTransitioning&&(await((pe=_.onPageTransitionStart)==null?void 0:pe.call(_,u)),_.isTransitioning=!0,d()))return;if(c){l(!m.pageContextFromRoute),l(!m.err);try{m.pageContextFromHooks=await jn(u)}catch(y){C(y)}if(d())return}else if(!m.err){const{pageContextFromRoute:y}=m;l(y),l(y._pageId),l(P(y,"_pageId","string")),p(u,y);try{m.pageContextFromHooks=await Ln(u)}catch(R){C(R)}if(d())return}if("err"in m){const{err:y}=m;if(Pe(y)||console.error(y),Ce(y,u,c))return;if(Pe(y)){const R=y;In(y,u._isProduction,u);const w=R._pageContextAbort;if(w._urlRewrite){await H({...e,scrollTarget:"scroll-to-top-or-hash",pageContextsFromRewrite:[...i,w]});return}if(w._urlRedirect){const J=w._urlRedirect.url;if(J.startsWith("http")){window.location.href=J;return}else await H({...e,scrollTarget:"scroll-to-top-or-hash",urlOriginal:J,overwriteLastHistoryEntry:!1,isBackwardNavigation:!1,redirectCount:a+1});return}l(w.abortStatusCode),p(u,w),w.abortStatusCode===404&&p(u,{is404:!0})}else p(u,{is404:!1});try{m.pageContextFromHooks=await Bn(u)}catch(R){if(Ce(R,u,c)||(c||setTimeout(()=>{window.location.pathname=n},0),un(y,R)))return;throw R}if(d())return}const{pageContextFromHooks:ge}=m;if(l(ge),p(u,ge),q(u,"onPageTransitionStart"),_.onPageTransitionStart=u.exports.onPageTransitionStart,u.exports.hydrationCanBeAborted?b():S(!ln(),"You seem to be using React; we recommend setting hydrationCanBeAborted to true, see https://vike.dev/clientRouting",{onlyOnce:!0}),!d()&&!(_.renderPromise&&(await _.renderPromise,l(_.renderPromise===void 0),d()))){if(Hr(n,r),_.previousPageContext=u,l(_.renderPromise===void 0),_.renderPromise=(async()=>{await wt(u,!0),xr(u),_.renderPromise=void 0})(),await _.renderPromise,l(_.renderPromise===void 0),c){q(u,"onHydrationEnd");const{onHydrationEnd:y}=u.exports;if(y){const R=u.exportsAll.onHydrationEnd[0].exportSource;if(l(R),await re(()=>y(u),"onHydrationEnd",R),d(!0))return}}if(!d(!0)){if(j){if(u.exports.onPageTransitionEnd&&(q(u,"onPageTransitionEnd"),await u.exports.onPageTransitionEnd(u),d(!0)))return;_.isTransitioning=void 0}lt(t),de(),Ar()}}}function Hr(e,t){se()!==e&&(de(),hn(e,t),Tr())}function Ce(e,t,n){return!!(zn(e)||Nr(e,t,n))}function Nr(e,t,n){if(!ie(e))return!1;if(n)throw ne(e,!1),e;return ne(e,!0),U(t.urlOriginal),!0}function ne(e,t){l(ie(e)),_.clientRoutingIsDisabled=!0,t&&console.log(e),oe(!1,["Failed to fetch static asset.","This usually happens when a new frontend is deployed.","Falling back to Server Routing.","(The next page navigation will use Server Routing instead of Client Routing.)"].filter(Boolean).join(" "),{onlyOnce:!0})}function jr(){const e=++_.renderCounter;l(e>=1);let t=!1;return{abortRender:o=>!o&&e===1&&!t?!1:e!==_.renderCounter,setHydrationCanBeAborted:()=>{t=!0},isFirstRender:e===1}}function Oe(){return _.renderCounter}function Br(){document.addEventListener("click",Lr)}function Lr(e){if(!Wr(e))return;const t=Dr(e.target);if(!t)return;const n=t.getAttribute("href");if(tt(t))return;l(n),e.preventDefault();const o=![null,"false"].includes(t.getAttribute("keep-scroll-position"))?"preserve-scroll":"scroll-to-top-or-hash";H({scrollTarget:o,urlOriginal:n,isBackwardNavigation:!1})}function Wr(e){return e.button===0&&!e.ctrlKey&&!e.shiftKey&&!e.altKey&&!e.metaKey}function Dr(e){for(;e.tagName!=="A";){const{parentNode:t}=e;if(!t)return null;e=t}return e}function Vr(){Ir(),Le(),$r(),yn(),l(Oe()===0),H({scrollTarget:"preserve-scroll",isBackwardNavigation:null,isClientSideNavigation:!1}),l(Oe()===1),Br(),Er()}N();const Ur=!0;vt(Ur);Vr();
